#!/bin/bash
# CRC: crc-MCPScript.md, crc-CheckpointManager.md
dir=$(dirname "$(realpath "$0")")
port=$(cat "$dir/mcp-port")
prog="$1"
shift

help() {
    cat 1>&2 <<here
usage: mcp [--help | PROG [options]]

mcp --help                      this message
mcp audit APP                   run code quality audit on APP
mcp patterns                    list available patterns with frontmatter
mcp checkpoint CMD APP [MSG]    manage app checkpoints (save/list/rollback/diff/clear/baseline/count/update/local)
mcp browser                     open browser to UI session
mcp display APP                 display APP in the browser
mcp event                       wait for next UI event (120s timeout)
mcp linkapp add|remove APP      manage app symlinks
mcp progress APP PERCENT STAGE  report build progress
mcp run 'lua code'              execute Lua code in session
mcp state                       get current session state
mcp status                      get server status
mcp theme list                  list available themes
mcp theme classes [THEME]       list semantic classes for theme
mcp theme audit APP [THEME]     audit app's theme class usage
mcp update                      smart update (hash-based conflict detection)
mcp update -t                   check for new version (report only, no changes)
mcp variables                   get current variable values
here
}

ensure_fossil() {
    FOSSIL_BIN="$HOME/.claude/bin/fossil"
    if [ -x "$FOSSIL_BIN" ]; then
        return 0
    fi
    echo "Downloading fossil..." >&2
    mkdir -p "$HOME/.claude/bin"

    # Get latest version from changes page
    version=$(curl -sL "https://fossil-scm.org/home/doc/trunk/www/changes.wiki" | grep -oP '(?<=<h2 id="v)[0-9]+_[0-9]+' | head -1 | tr '_' '.')
    if [ -z "$version" ]; then
        version="2.27"  # fallback
    fi

    case "$(uname -s)-$(uname -m)" in
        Linux-x86_64)
            url="https://fossil-scm.org/home/uv/fossil-linux-x64-${version}.tar.gz"
            ;;
        Darwin-arm64)
            url="https://fossil-scm.org/home/uv/fossil-mac-arm-${version}.tar.gz"
            ;;
        Darwin-x86_64)
            url="https://fossil-scm.org/home/uv/fossil-mac-x64-${version}.tar.gz"
            ;;
        *)
            echo "Unsupported platform: $(uname -s)-$(uname -m)" >&2
            exit 1
            ;;
    esac
    curl -sL "$url" | tar -xzf - -C "$HOME/.claude/bin" fossil
    chmod +x "$FOSSIL_BIN"
}

checkpoint_save() {
    local app="$1" msg="$2"
    local app_dir="$dir/apps/$app"
    local repo="$app_dir/checkpoint.fossil"

    if [ ! -d "$app_dir" ]; then
        echo "App not found: $app" >&2
        exit 1
    fi

    ensure_fossil
    cd "$app_dir"

    if [ ! -f "$repo" ]; then
        # Initialize new repo
        "$FOSSIL_BIN" init "$repo" --project-name "$app" >/dev/null
        "$FOSSIL_BIN" open "$repo" --force >/dev/null
        "$FOSSIL_BIN" settings ignore-glob '.#*,.*~,*~,checkpoint.fossil,.fslckout'
        # Add all files and create first check-in with app contents
        "$FOSSIL_BIN" add . >/dev/null 2>&1
        "$FOSSIL_BIN" commit -m "${msg:-initial state}" --no-warnings >/dev/null
        echo "Created checkpoint: ${msg:-initial state}"
        # Notify UI of checkpoint change
        "$dir/mcp" run "if appConsole then appConsole._checkpointsTime = 0 end" >/dev/null 2>&1
    else
        # Add new files and remove deleted files, then check for changes
        "$FOSSIL_BIN" addremove >/dev/null 2>&1
        if "$FOSSIL_BIN" changes --quiet | grep -q .; then
            "$FOSSIL_BIN" commit -m "${msg:-checkpoint}" --no-warnings >/dev/null
            echo "Saved checkpoint: ${msg:-checkpoint}"
            # Notify UI of checkpoint change
            "$dir/mcp" run "if appConsole then appConsole._checkpointsTime = 0 end" >/dev/null 2>&1
        else
            echo "No changes to checkpoint"
        fi
    fi
}

checkpoint_list() {
    local app="$1"
    local app_dir="$dir/apps/$app"
    local repo="$app_dir/checkpoint.fossil"

    if [ ! -f "$repo" ]; then
        echo "No checkpoints for $app"
        exit 0
    fi

    ensure_fossil
    cd "$app_dir"
    # Remove date headers, baseline, and fossil artifacts
    "$FOSSIL_BIN" timeline -t ci --oneline | head -n -3
}

checkpoint_rollback() {
    local app="$1" n="$2"
    local app_dir="$dir/apps/$app"
    local repo="$app_dir/checkpoint.fossil"

    if [ ! -f "$repo" ]; then
        echo "No checkpoints for $app" >&2
        exit 1
    fi

    ensure_fossil
    cd "$app_dir"

    if [ -z "$n" ]; then
        # Undo last change
        "$FOSSIL_BIN" undo
    else
        # Get hash of nth commit (1-indexed, excluding baseline and artifacts)
        local hash=$("$FOSSIL_BIN" timeline -n 100 -t ci --oneline | grep -v '^---\|^+++\|=== BASELINE ===' | head -n "$n" | tail -1 | cut -d' ' -f1)
        if [ -z "$hash" ]; then
            echo "Checkpoint $n not found" >&2
            exit 1
        fi
        "$FOSSIL_BIN" checkout "$hash" --force
    fi
    echo "Rolled back to checkpoint"
}

checkpoint_diff() {
    local app="$1" n="${2:-1}"
    local app_dir="$dir/apps/$app"
    local repo="$app_dir/checkpoint.fossil"

    if [ ! -f "$repo" ]; then
        echo "No checkpoints for $app" >&2
        exit 1
    fi

    ensure_fossil
    cd "$app_dir"

    # Get hash of nth commit (1-indexed, excluding baseline and artifacts)
    local hash=$("$FOSSIL_BIN" timeline -t ci --oneline | head -n -3 | head -n "$n" | tail -1 | cut -d' ' -f1)
    if [ -z "$hash" ]; then
        echo "Checkpoint $n not found" >&2
        exit 1
    fi
    "$FOSSIL_BIN" diff --from "$hash"
}

checkpoint_clear() {
    # Clear = reset to baseline (same as baseline command)
    checkpoint_baseline "$1"
}

checkpoint_baseline() {
    local app="$1"
    local app_dir="$dir/apps/$app"
    local repo="$app_dir/checkpoint.fossil"

    if [ ! -d "$app_dir" ]; then
        echo "App not found: $app" >&2
        exit 1
    fi

    ensure_fossil
    cd "$app_dir"

    local has_bundle=false
    local bundle="$app_dir/.preserved-bundle"

    if [ -f "$repo" ]; then
        # Export updates and local branches (if they exist) into a single bundle
        # Note: one --branch per export call; second call appends to same bundle
        rm -f "$bundle"
        for branch in updates local; do
            if "$FOSSIL_BIN" branch list 2>/dev/null | grep -q "$branch"; then
                "$FOSSIL_BIN" bundle export "$bundle" --branch "$branch" --standalone 2>/dev/null && has_bundle=true
            fi
        done
        "$FOSSIL_BIN" close --force 2>/dev/null
        rm -f "$repo" .fslckout
    fi

    # Create fresh repo with current state as baseline
    "$FOSSIL_BIN" init "$repo" --project-name "$app" >/dev/null
    "$FOSSIL_BIN" open "$repo" --force >/dev/null
    "$FOSSIL_BIN" settings ignore-glob '.#*,.*~,*~,checkpoint.fossil,.fslckout'
    "$FOSSIL_BIN" add . >/dev/null 2>&1
    "$FOSSIL_BIN" commit -m "=== BASELINE ===" --no-warnings >/dev/null

    # Restore preserved branches from bundle
    if [ "$has_bundle" = true ] && [ -f "$bundle" ]; then
        "$FOSSIL_BIN" bundle import "$bundle" --force --publish 2>/dev/null
        rm -f "$bundle"
        echo "Baseline set for $app (preserved branches restored)"
    else
        echo "Baseline set for $app"
    fi
    # Notify UI of checkpoint change
    "$dir/mcp" run "if appConsole then appConsole._checkpointsTime = 0 end" >/dev/null 2>&1
}

checkpoint_count() {
    local app="$1"
    local app_dir="$dir/apps/$app"
    local repo="$app_dir/checkpoint.fossil"

    if [ ! -f "$repo" ]; then
        echo "0"
        exit 0
    fi

    ensure_fossil
    cd "$app_dir"
    # Count trunk commits excluding baseline, initial, and fossil footer
    local count=$("$FOSSIL_BIN" timeline -t ci --oneline -b trunk | grep -v "=== BASELINE ===" | grep -v "initial empty check-in" | grep -v "^+++ " | wc -l)
    echo "$count"
}

# CRC: crc-CheckpointManager.md | R125
checkpoint_update() {
    local app="$1" msg="$2"
    local app_dir="$dir/apps/$app"
    local repo="$app_dir/checkpoint.fossil"

    if [ ! -d "$app_dir" ]; then
        echo "App not found: $app" >&2
        exit 1
    fi

    ensure_fossil
    cd "$app_dir"

    if [ ! -f "$repo" ]; then
        # No repo yet — init, trunk baseline first, then updates branch
        "$FOSSIL_BIN" init "$repo" --project-name "$app" >/dev/null
        "$FOSSIL_BIN" open "$repo" --force >/dev/null
        "$FOSSIL_BIN" settings ignore-glob '.#*,.*~,*~,checkpoint.fossil,.fslckout'
        "$FOSSIL_BIN" add . >/dev/null 2>&1
        "$FOSSIL_BIN" commit -m "=== BASELINE ===" --no-warnings >/dev/null
        # Create updates branch from trunk (same content)
        "$FOSSIL_BIN" commit --branch updates -m "${msg:-update}" --allow-empty --no-warnings >/dev/null
        "$FOSSIL_BIN" update trunk >/dev/null 2>&1
    else
        # Require no uncommitted checkpoints (user must consolidate first)
        local count
        count=$("$dir/mcp" checkpoint count "$app" 2>/dev/null || echo "0")
        if [ "$count" != "0" ]; then
            echo "Error: $count checkpoint(s) exist. Consolidate with /ui-thorough before updating." >&2
            exit 1
        fi
        # Switch to updates branch (create if needed), commit, switch back
        if ! "$FOSSIL_BIN" update updates >/dev/null 2>&1; then
            "$FOSSIL_BIN" addremove >/dev/null 2>&1
            "$FOSSIL_BIN" commit --branch updates -m "${msg:-update}" --allow-empty --no-warnings >/dev/null
        else
            "$FOSSIL_BIN" addremove >/dev/null 2>&1
            "$FOSSIL_BIN" commit -m "${msg:-update}" --allow-empty --no-warnings >/dev/null
        fi
        "$FOSSIL_BIN" update trunk >/dev/null 2>&1
    fi
    echo "Update checkpoint: ${msg:-update}"
}

# CRC: crc-CheckpointManager.md | R126
checkpoint_local() {
    local app="$1" msg="$2"
    local app_dir="$dir/apps/$app"
    local repo="$app_dir/checkpoint.fossil"

    if [ ! -d "$app_dir" ]; then
        echo "App not found: $app" >&2
        exit 1
    fi

    ensure_fossil
    cd "$app_dir"

    if [ ! -f "$repo" ]; then
        # No repo yet — init, trunk baseline first, then local branch
        "$FOSSIL_BIN" init "$repo" --project-name "$app" >/dev/null
        "$FOSSIL_BIN" open "$repo" --force >/dev/null
        "$FOSSIL_BIN" settings ignore-glob '.#*,.*~,*~,checkpoint.fossil,.fslckout'
        "$FOSSIL_BIN" add . >/dev/null 2>&1
        "$FOSSIL_BIN" commit -m "=== BASELINE ===" --no-warnings >/dev/null
        # Create local branch from trunk (same content)
        "$FOSSIL_BIN" commit --branch local -m "${msg:-local}" --allow-empty --no-warnings >/dev/null
        "$FOSSIL_BIN" update trunk >/dev/null 2>&1
    else
        # Switch to local branch (create if needed), commit, switch back
        if ! "$FOSSIL_BIN" update local >/dev/null 2>&1; then
            "$FOSSIL_BIN" addremove >/dev/null 2>&1
            "$FOSSIL_BIN" commit --branch local -m "${msg:-local}" --allow-empty --no-warnings >/dev/null
        else
            "$FOSSIL_BIN" addremove >/dev/null 2>&1
            "$FOSSIL_BIN" commit -m "${msg:-local}" --allow-empty --no-warnings >/dev/null
        fi
        "$FOSSIL_BIN" update trunk >/dev/null 2>&1
    fi
    echo "Local checkpoint: ${msg:-local}"
}

case "$prog" in
    help | --help)
        help
        ;;
    checkpoint)
        cmd="$1"
        app="$2"
        case "$cmd" in
            save)
                checkpoint_save "$app" "$3"
                ;;
            list)
                checkpoint_list "$app"
                ;;
            rollback)
                checkpoint_rollback "$app" "$3"
                ;;
            diff)
                checkpoint_diff "$app" "$3"
                ;;
            clear)
                checkpoint_clear "$app"
                ;;
            baseline)
                checkpoint_baseline "$app"
                ;;
            count)
                checkpoint_count "$app"
                ;;
            update)
                checkpoint_update "$app" "$3"
                ;;
            local)
                checkpoint_local "$app" "$3"
                ;;
            *)
                echo "Usage: mcp checkpoint save|list|rollback|diff|clear|baseline|count|update|local APP [arg]" >&2
                exit 1
                ;;
        esac
        ;;
    audit)
        app="$1"
        if [ -z "$app" ]; then
            echo "Usage: ./audit <appname>"
            exit 1
        fi
        exec curl -s -X POST "http://127.0.0.1:$port/api/ui_audit" \
             -H "Content-Type: application/json" \
             -d "{\"name\": \"$app\"}"
        ;;
    patterns)
        patterns_dir="$dir/patterns"
        if [ ! -d "$patterns_dir" ]; then
            echo "No patterns directory"
            exit 0
        fi
        for file in "$patterns_dir"/*.md; do
            [ -e "$file" ] || continue
            # Extract frontmatter (between --- markers)
            desc=$(sed -n '/^---$/,/^---$/{ /^description:/s/^description: *//p }' "$file")
            basename="${file##*/}"
            basename="${basename%.md}"
            echo "- \`$basename.md\` - $desc"
        done
        ;;
    browser)
        exec curl -s -X POST "http://127.0.0.1:$port/api/ui_open_browser" \
             -H "Content-Type: application/json" \
             -d '{}'
        ;;
    display)
        name="${1:?Usage: display <app-name>}"
        exec curl -s -X POST "http://127.0.0.1:$port/api/ui_display" \
             -H "Content-Type: application/json" \
             -d "$(jq -n --arg name "$name" '{name: $name}')"
        ;;
    event)
        # kill previous event watcher for this config if there is one
        if [ -f "$dir/.eventpid" ]; then
            if [ "$(ps --no-headers -o comm $(cat "$dir/.eventpid"))" = bash ]; then
                kill "$dir/.eventpid"
            fi
        fi
        echo $BASHPID > "$dir/.eventpid"
        while true; do
            out="$(curl -s "http://127.0.0.1:$port/wait?timeout=120")"
            status=$?
            if [ -n "$out" ]; then
                echo "$out"
                rm "$dir/.eventpid"
                echo '{"note":"Restart the event loop in the background: .ui/mcp event"}'
                break
            elif [ $status != 0 ]; then
                rm "$dir/.eventpid"
                if [ $status = 127 ]; then
                    echo '{"note":"Event loop timed out. Restart: .ui/mcp event"}'
                else
                    echo '{"note":"Event exited with an error. Restart: .ui/mcp event"}'
                fi
                exit $status
            fi
        done
        ;;
    linkapp)
        exec "$dir/linkapp" "$@"
        ;;
    progress)
        app="${1:?Usage: progress <app> <percent> <stage>}"
        percent="${2:?Usage: progress <app> <percent> <stage>}"
        stage="${3:?Usage: progress <app> <percent> <stage>}"
        code="mcp:appProgress('$app', $percent, '$stage'); mcp:addAgentThinking('$stage')"
        exec curl -s -X POST "http://127.0.0.1:$port/api/ui_run" \
             -H "Content-Type: application/json" \
             -d "$(jq -n --arg code "$code" '{code: $code}')"
        ;;
    run)
        if [ -n "$FRICTIONLESS_MCP" ]; then
            # if being called from inside the MCP, do nothing
            exit
        fi
        code="${1:?Usage: run '<lua code>'}"
        exec curl -s -X POST "http://127.0.0.1:$port/api/ui_run" \
             -H "Content-Type: application/json" \
             -d "$(jq -n --arg code "$code" '{code: $code}')"
        ;;
    state)
        exec curl -s "http://127.0.0.1:$port/state"
        ;;
    status)
        exec curl -s "http://127.0.0.1:$port/api/ui_status"
        ;;
    update)
        if [ "$1" = "-t" ]; then
            # Test mode: check for updates without applying
            current=$(curl -s "http://127.0.0.1:$port/api/ui_status" | jq -r '.result.version // "unknown"')
            latest=$(curl -s --connect-timeout 5 --max-time 10 \
                "https://api.github.com/repos/zot/frictionless/releases/latest" 2>/dev/null \
                | jq -r '.tag_name // empty' | sed 's/^v//')
            if [ -z "$latest" ]; then
                echo '{"error":"Could not fetch latest version from GitHub"}'
                exit 1
            fi
            needs_update="false"
            if [ "$(printf '%s\n%s' "$current" "$latest" | sort -V | tail -1)" != "$current" ]; then
                needs_update="true"
            fi
            jq -n --arg current "$current" --arg latest "$latest" --argjson needs "$needs_update" \
                '{current: $current, latest: $latest, needsUpdate: $needs}'
        else
            # Perform smart update
            exec curl -s -X POST "http://127.0.0.1:$port/api/ui_update" \
                 -H "Content-Type: application/json" \
                 -d '{}'
        fi
        ;;
    theme)
        # Theme commands use CLI directly (no server needed)
        exec "$HOME/.claude/bin/frictionless" theme "$@" --dir "$dir"
        ;;
    variables)
        exec curl -s "http://127.0.0.1:$port/variables"
        ;;
    *)
        echo 1>&2 "Unknown command: $1"
        exit 1
        ;;
esac
